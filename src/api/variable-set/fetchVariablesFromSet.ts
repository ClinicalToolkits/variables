import { VariableSet, Variable } from "../../types";
import { getDBVariableIds } from "../../utility";
import { fetchVariables } from "../fetchVariable";

export async function fetchVariablesFromSet(variableSet: VariableSet, bInIncludeAutoGeneratedVariables?: boolean): Promise<Variable[]> {
  const variableIds = getDBVariableIds(variableSet.variableIds.all);
  console.log("fetchVariablesFromSet variableSet:", variableSet);
  try {
    return await fetchVariables({
      variableIds,
      entityId: variableSet.idToken.entityId,
      entityVersionId: variableSet.idToken.entityVersionId,
      labelPrefix: variableSet.label,
      variableSetId: variableSet.idToken.id,
      descriptiveRatingId: variableSet.metadata?.descriptiveRatingId,
      bIncludeAutoGeneratedVariables: bInIncludeAutoGeneratedVariables,
    })
  } catch (error) {
    console.error(`Failed to fetch variables for variable set ${variableSet.idToken}:`, error);
    throw error;
  }
};

/*
    try {
      const { data, error } = await supabaseClient
        .from("variables")
        .select("*")
        .in("id", variableIds);

      if (error) {
        throw new Error(`Supabase error: ${error.message}`);
      }
  
      const finalData: Variable[] =
        await data?.reduce<Promise<Variable[]>>(
          async (accPromise, { id, full_name, abbreviated_name, data_type, variable_set_tag, tags, subgroup_tag, order_within_set, metadata, ...rest }) => {
            const acc = await accPromise;

            // Convert database rows to application model
            const convertedVariable: Variable = {
              ...rest,
              id: id,
              key: variableSet.subversion ? `${id}_${variableSet.subversion}` : id,
              fullName: full_name,
              abbreviatedName: abbreviated_name,
              dataType: data_type,
              variableSetTag: null,
              variableSubsetId: variableSet.id,
              variableSetKey: variableSet.key,
              tags: null,
              value: undefined,
              subgroupTag: convertStringToTag(subgroup_tag),
              orderWithinSet: order_within_set,
              metadata: metadata && {
                ...metadata,
                properties: metadata.properties && {
                  ...metadata?.properties,
                  sectionSubversion: variableSet.subversion,
                },
                associatedCompositeVariableKey: metadata.associatedCompositeVariableId ? variableSet.subversion ? `${metadata.associatedCompositeVariableId}_${variableSet.subversion}` : metadata.associatedCompositeVariableId : undefined,
                associatedSubvariables: metadata.associatedSubvariableIds
                ? metadata.associatedSubvariableIds.map((id: string) => {
                    const keyWithOptionalSubversion = variableSet.subversion ? `${id}_${variableSet.subversion}` : id;
                    return {
                      id,
                      key: keyWithOptionalSubversion, // Assuming you want the modified key as the id; if not, just use `id`.
                      fullName: "accumulatorPlaceholder",
                      bValueEntered: false,
                    };
                  })
                : undefined,
              },
            };

            if (convertedVariable.metadata?.descriptiveRatingId) {
              getDescriptiveRatingsById(convertedVariable.metadata.descriptiveRatingId).then((ratings) => {
                convertedVariable.metadata!.descriptiveRatings = ratings;
              });
            }

            acc.push(convertedVariable);

            if (convertedVariable.metadata?.bCreatePercentileRank) {
              const percentileRankVariable = createPercentileRankVariable(convertedVariable);
              acc.push(percentileRankVariable);
            }

            if (convertedVariable.metadata?.bCreateDescriptiveRating) {
              const descriptorVariable = createDescriptorVariable(convertedVariable);
              acc.push(descriptorVariable);
            }

            return acc; // Remember to return the accumulated value
          },
          Promise.resolve([]) // Start with a resolved promise of an empty array
        ) ?? [];

        // Enrich the associatedSubvariables with actual subvariable names
        for (const variable of finalData) {
          if (variable.metadata?.associatedSubvariables) {
            // Map through each associatedSubvariable to update its properties
            const enrichedSubvariables = variable.metadata.associatedSubvariables.map(subvar => {
              // Find the subvariable in finalData using the enriched subvar's id
              const correspondingSubvar = finalData.find(v => v.key === subvar.id);
              
              if (correspondingSubvar) {
                // If a matching subvariable is found, enrich the current subvar object
                return {
                  ...subvar,
                  fullName: correspondingSubvar.fullName, // Or any other property you need to update
                };
              }
              // If no matching subvariable is found, return the subvar as is
              return subvar;
            });

            // Update the variable's associatedSubvariables with the enriched data
            variable.metadata.associatedSubvariables = enrichedSubvariables;
          }
        }

      return finalData;
    } catch (error) {
      console.error(`Failed to fetch variables by variable subset ${variableSet.key}:`, error);
      throw error;
    }
    */