import { cloneTemplateBlock } from "@clinicaltoolkits/content-blocks";
import { getChildVariableIds, getParentVariableId, getVariableIdFromString, Variable } from "..";
import { setInternalMetadata } from "./internalMetadata";
import { generateUUID } from "@clinicaltoolkits/type-definitions";
import { logger } from "@clinicaltoolkits/utility-functions";

interface CloneVariableOptions {
    variableToClone: Variable;
    newVariableId: string;
    entityId: string;
    entityInstanceId: string;
    variableIdMap?: Record<string, string>;
  }
  
  export const cloneVariable = ({
    variableToClone,
    newVariableId,
    entityId,
    entityInstanceId,
    variableIdMap = {},
  }: CloneVariableOptions): Variable => {
    const newIdToken = variableToClone.idToken.cloneWithChanges({
      variableId: newVariableId,
      entityId,
      entityVersionId: entityInstanceId,
    });
  
    const clonedVariable: Variable = {
      ...variableToClone,
      idToken: newIdToken,
      entityId,
      entityVersionId: entityInstanceId,
      // Important: set the id to the new one
      ...newIdToken, // In case you want to flatten it
    };
  
    // Clone content blocks if present
    if (variableToClone.content) {
      clonedVariable.content = {
        ...variableToClone.content,
        description: variableToClone.content.description
          ? cloneTemplateBlock({
              block: variableToClone.content.description,
              variableIdMap,
              entityId,
              entityInstanceId,
            })
          : undefined,
        interpretation: variableToClone.content.interpretation
          ? cloneTemplateBlock({
              block: variableToClone.content.interpretation,
              variableIdMap,
              entityId,
              entityInstanceId,
            })
          : undefined,
      };
    }
  
    // Optional: Clone and remap childVariableIds
    const childVariableIds = getChildVariableIds(variableToClone);
    if (childVariableIds.length) {
      clonedVariable.metadata = {
        ...variableToClone.metadata,
        childVariableIds: childVariableIds.map(
          (oldId) => variableIdMap[oldId] || oldId
        ),
      };
    }

    setInternalMetadata(clonedVariable, {
        _origin: "cloned",
      });
  
    return clonedVariable;
  };
  
interface IBatchCloneVariableOptions extends Omit<CloneVariableOptions, "variableToClone" | "newVariableId" | "variableIdMap"> {
  variablesToClone: Variable[];
}
interface IBatchCloneVariableResult {
  clonedVariables: Variable[];
  variableIdMap: Record<string, string>;
}
export const batchCloneVariable = ({ variablesToClone, entityId, entityInstanceId }: IBatchCloneVariableOptions): IBatchCloneVariableResult => {
  const variableIdMap: Record<string, string> = {};

   // 1. Work on a copy so we don’t reorder the caller’s array
  const sortedVariablesToClone = [...variablesToClone].sort((a, b) => {
    const aAuto = a.metadata?.bAutoGenerated ? 1 : 0;
    const bAuto = b.metadata?.bAutoGenerated ? 1 : 0;
    return aAuto - bAuto; // non-auto (0) before auto (1)
  });
  
  // 2. First pass: seed the map with new UUIDs for *every* variable
  for (const variable of sortedVariablesToClone) {
    const oldId = variable.idToken.variableId;
    variableIdMap[oldId] = generateUUID();
  }

  // 3. Second pass: override the auto generated variables to preserve suffix
  const clonedVariables = sortedVariablesToClone.map(variable => {
    const oldId = variable.idToken.variableId;
    let newVariableId = variableIdMap[oldId]!;

    if (variable.metadata?.bAutoGenerated) {
      // split at the *first* underscore
      const idx = oldId.indexOf('_');
      if (idx !== -1) {
        const parentOldId = oldId.slice(0, idx);          // Returns the part before the first underscore, this corresponds to the original parent variable's id
        const suffix      = oldId.slice(idx + 1);         // Returns the part after the first underscore
        const parentNewId = variableIdMap[parentOldId];   // Use the original parent variable's id to find the replacement id we populated for it in the first pass
        // If the parent variable was cloned, we can use its new id to create the new id for the auto-generated variable
        if (parentNewId) {
          newVariableId = `${parentNewId}_${suffix}`;
          variableIdMap[oldId] = newVariableId;
        } else {
          // If the parent variable was not cloned we print an error and keep the old id
          logger.error(`batchCloneVariable() - Parent variable ${parentOldId} was not cloned. Keeping old id ${oldId} for auto-generated variable.`, sortedVariablesToClone);
          newVariableId = oldId;
        }
      }
    }

    const clonedVariable = cloneVariable({
      variableToClone: variable,
      newVariableId,
      entityId: entityId,
      entityInstanceId,
      variableIdMap,
    });

    return clonedVariable;
  });

  return {
    clonedVariables,
    variableIdMap,
  };
};
